{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/**\n * The goal of this file is to process these input tags:\n * <input type=\"file\" data-max-width=\"500\" data-max-height=\"500\" data-quality=\"90\" data-format=\"webp\" />\n * by listening to the file change and processing the image on the client.\n */\n\nconst load = (url: string): Promise<HTMLImageElement> => {\n  return new Promise<HTMLImageElement>((fulfill, _reject) => {\n    let imageObj = new Image();\n\n    imageObj.onload = () => fulfill(imageObj);\n    imageObj.src = url;\n  });\n};\n\nfunction onChangeImage(input: HTMLInputElement, event: Event) {\n  const maxWidth = input.dataset.maxWidth ? parseInt(input.dataset.maxWidth) : 500;\n  const maxHeight = input.dataset.maxHeight ? parseInt(input.dataset.maxHeight) : 500;\n  const quality = input.dataset.quality ? parseInt(input.dataset.quality) : 90;\n  const format = input.dataset.format ? input.dataset.format : 'webp';\n  const fit = input.dataset.fit ? input.dataset.fit : 'fit';\n  const preview = input.dataset.preview;\n  const previewElement = preview ? document.querySelector(preview) as HTMLImageElement : null;\n  const reader = new FileReader();\n  reader.onload = event => {\n    Promise.all([\n      load(event.target!.result as string)\n    ]).then(images => {\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d')!;\n      if (fit === 'fit') {\n        const originalWidth = images[0].width;\n        const originalHeight = images[0].height;\n        // fit the image in the maxWidth and maxHeight\n        let imageWidth = originalWidth;\n        let imageHeight = originalHeight;\n        if (originalWidth > maxWidth) {\n          imageWidth = maxWidth;\n          imageHeight = originalHeight * maxWidth / originalWidth;\n        }\n        if (imageHeight > maxHeight) {\n          imageHeight = maxHeight;\n          imageWidth = originalWidth * maxHeight / originalHeight;\n        }\n        canvas.width = imageWidth;\n        canvas.height = imageHeight;\n        context.drawImage(images[0], 0, 0, imageWidth, imageHeight);\n      } else {\n        canvas.width = maxWidth;\n        canvas.height = maxHeight;\n        // let the image fill the maxWidth and maxHeight and crop the rest\n        const ratio = Math.max(maxWidth / images[0].width, maxHeight / images[0].height);\n        const newWidth = images[0].width * ratio;\n        const newHeight = images[0].height * ratio;\n        const offsetX = (newWidth - maxWidth) / 2;\n        const offsetY = (newHeight - maxHeight) / 2;\n        context.drawImage(images[0], -offsetX, -offsetY, newWidth, newHeight);\n      }\n      // convert the canvas to a blob\n      function processBlob(blob: Blob) {\n        if (previewElement) {\n          const url = URL.createObjectURL(blob);\n          previewElement.src = url;\n        }\n        // create a new file from the blob\n        const file = new File([blob], 'image.' + blob.type?.replace('image/', '') || 'jpg', {\n          type: blob.type,\n          lastModified: Date.now()\n        });\n        // replace the file in the input\n        const dataTransfer = new DataTransfer();\n        dataTransfer.items.add(file);\n        input.files = dataTransfer.files;\n      }\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          throw new Error('Failed to create blob for image');\n        }\n        // fallback to jpeg if we requested webp and got a png\n        if (blob.type === 'image/png' && format === 'webp') {\n          canvas.toBlob((blob) => {\n            if (!blob) {\n              throw new Error('Failed to create blob for image');\n            }\n            processBlob(blob);\n          }, 'image/jpeg', quality / 100);\n        }\n        processBlob(blob);\n      }, `image/${format}`, quality / 100);\n    })\n  }\n\n  reader.readAsDataURL(input.files![0]);\n}\n\nfunction init() {\n  document.querySelectorAll('input[data-format], input[data-max-width], input[data-max-height], input[data-quality]').forEach((input) => {\n    input.addEventListener('change', (event) => {\n      onChangeImage(input as HTMLInputElement, event);\n    });\n  });\n}\n\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    init();\n  });\n} else {\n  init();\n}\n\nconst observer = new MutationObserver((mutations) => {\n  mutations.forEach((mutation) => {\n    if (mutation.addedNodes.length) {\n      // check if the added node is an input\n      if (mutation.addedNodes[0].nodeName === 'INPUT') {\n        const input = mutation.addedNodes[0] as HTMLInputElement;\n        if (input.dataset.format || input.dataset.maxWidth || input.dataset.maxHeight || input.dataset.quality) {\n          input.addEventListener('change', (event) => {\n            onChangeImage(input, event);\n          });\n        }\n      }\n    }\n  });\n});"],
  "mappings": "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",
  "names": ["load", "url", "fulfill", "_reject", "imageObj", "onChangeImage", "input", "event", "maxWidth", "maxHeight", "quality", "format", "fit", "preview", "previewElement", "reader", "images", "canvas", "context", "originalWidth", "originalHeight", "imageWidth", "imageHeight", "ratio", "newWidth", "newHeight", "offsetX", "offsetY", "processBlob", "blob", "file", "dataTransfer", "init", "observer", "mutations", "mutation"]
}
